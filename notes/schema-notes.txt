You can find defintions for network messages in the NS2 lua directories:

Example from schema file:

  "81": {
    "id": 81,
    "name": "ScoreUpdate",
    "fields": [
      {
        "name": "points",
        "type": "Integer",
        "group": "Public",
        "maxBits": 14,
        "memBytes": 4,
        "components": [
          {
            "component": 0,
            "bits": 14,
            "stepValue": 1,
            "min_raw": 0,
            "range_raw": 9999
          }
        ]
      },
      {
        "name": "res",
        "type": "Integer",
        "group": "Public",
        "maxBits": 7,
        "memBytes": 4,
        "components": [
          {
            "component": 0,
            "bits": 7,
            "stepValue": 1,
            "min_raw": 0,
            "range_raw": 100
          }
        ]
      },
      {
        "name": "wasKill",
        "type": "Bool",
        "group": "Public",
        "maxBits": 1
      }
    ]
  },

Same definition in lua:

local kScoreUpdate =
{
    points = "integer (0 to " .. kMaxScore .. ")",
    res = "integer (0 to " .. kMaxPersonalResources .. ")",
    wasKill = "boolean"
}
Shared.RegisterNetworkMessage("ScoreUpdate", kScoreUpdate)

The Fields of the message as defined in the schema should be arranged alphabetically by the name field (order in which unpacked from the bit stream).

For Types:

      3 components: Angles, Vector, Position
      1 component : Angle, Fixed, Integer, Time
      0 component : Bool, String, Float (Float keeps maxBits only)
      memBytes(integer param) is only present for Integer

      Most Float data seems to be sent as Fixed type.

For the state packet processing which uses similar packing/unpacking as network message it does not appear that field order is sorted by name.

First 3 bytes are the Entity ID / Sync (de-sync detection) 2 bytes and the Class ID 1 byte.

Sync value is just a cycle per each read entity entry that goes 0->1->2->3->0 used to detect sync issue.  Resets to 0 on each state packet.

If the Class ID is FF that means that class data should not be carried over into the new modified state (destroyed).

For a baseline copy (no previous state) it should be straightforward to read the data and build a state.  Thereafter there is a diff routine that has differnet operating modes (sparse/etc) so that only changed field data needs to be sent.
